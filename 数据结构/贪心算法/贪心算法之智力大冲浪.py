#!/usr/bin/python3
# 文件名: 贪心算法之智力大冲浪
# 作者：巧若拙
# 时间：2018-12-29

'''
例1  智力大冲浪（riddle.pas）。

【题目描述】
小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者m元。
先不要太高兴！因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：
首先，比赛时间分为n个时段(n≤500)，它又给出了很多小游戏，每个小游戏都必须在规定期限ti前完成(1≤ti≤n)。
如果一个游戏没能在规定期限前完成，则要从奖励费m元中扣去一部分钱wi，wi为自然数，不同的游戏扣去的钱是不一样的。
当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。
主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！
注意：比赛绝对不会让参赛者赔钱!

【输入】
输入文件riddle.in，共4行。
第一行为m，表示一开始奖励给每位参赛者的钱；
第二行为n，表示有n个小游戏；
第三行有n个数，分别表示游戏1～n的规定完成期限；
第四行有n个数，分别表示游戏1～n不能在规定期限前完成的扣款数。

【输出】
输出文件riddle.out，仅1行。表示小伟能赢取最多的钱。

【样例输入】
10000
7
4 2 4 3 1 4 6
70 60 50 40 30 20 10

【样例输出】
9950

【算法分析】
因为不同的小游戏不能准时完成时具有不同的扣款权数，而且是最优解问题，所以本题很容易就想到了贪心法。
贪心的主要思想是要让扣款数值大的尽量准时完成。这样我们就先把这些任务按照扣款的数目进行排序，把大的排在前面，先进行放置。
假如罚款最多的一个任务的完成期限是k，我们应该把它安排在哪个时段完成呢？应该放在第k个时段，因为放在1～k任意一个位置，效果都是一样的。
若第k个时段已经有任务占据，则向前查询是否有空的时间段，若完成期限之前的时间段全部被占据，则放弃该任务。
这样能获得最优结果。
'''
def fun(a): #返回扣除奖金的最小值
    b = [True] * len(a)
    c = 0
    for i in range(len(a)):
        k = a[i][1]
        while k > 0 and not b[k]:
            k -= 1
        if k > 0:
            b[k] = False
        else:
            c += a[i][0]
    return c
    
def main():
    with open('zldcl.txt', 'r') as fin:
        with open('zldcl.out', 'w') as fout:
            m = int(fin.readline())
            n = int(fin.readline())
            t = tuple(map(int, fin.readline().split()))
            w = tuple(map(int, fin.readline().split()))
            a = list(zip(w, t))
            #print(m, n, t, w, a)
            a.sort(key=lambda x: x[0], reverse=True)
            #print(a)
            c = m - fun(a)
            print(c)
            fout.write(str(c))

main()
