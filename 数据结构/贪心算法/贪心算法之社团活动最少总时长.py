# -*- coding: utf-8 -*-
"""
Created on Sat Mar  9 21:08:22 2019

@author: Administrator
学校筹办社团节,每个社团先到A场地做“准备”,然后到B场地“风采展示汇报"。
同一场地，同一时间只允许一个社团使用。每个社团使用A、B场地时间都有所不同。
已知学校共n个社团，第i个社团使用A场地时长为a[i]分钟,使用B场地时长为b[i]分钟。
为了更高效地组织这次活动，需要计算此次活动的最小总时长和社团参会的顺序。
算法思路:
1.统计m[i]表示第i个社团中在A和B两个场地中用时的较小值。
2.按m[i]值从小到大排序，然后按m[i]值的顺序，逐个社团安排参会顺序，策略如下：
为了使得总时长最短，让A场地用时最少的最先开始；B场地用时最少的最后开始。
对于每个社团，若m[i]与该社团在A场地使用时间相同，则将它排在剩余的可排位置的最前面；
若m[i]与该社团B场地使用的时间相等，则将它安排在剩余可排位置的最后面。
例如: N=5，社团序号分别是(1, 2, 3, 4, 5)
1至5号社团使用A场地的时间依次为：(3, 5, 8, 7, 10)
1至5号社团使用B场地的时间依次为：(6, 2, 1, 4, 9)
按上述算法可求得5个社团m[i]的值依次为：(3, 2, 1, 4, 9)

"""

n = 5
a = (3,5,8,7,10)
b = (6,2,1,4,9)
a = (3 , 5 , 2 , 4 , 10)
b = (6 , 8 , 1 , 7 , 9)
m = []#m[i]表示第i个社团中在A和B两个场地中用时的较小值
for i in range(n):
    m.append(min(a[i], b[i]))
s = range(n)
ms = list(zip(m, s))
ms.sort(key=lambda x: x[0])#按m[i]值从小到大排序
print(ms)
ans = [-1] * n
k, t = 0, n-1
for i in range(n):#安排社团出场顺序，准备用时少的靠前，表演用时少的靠后
    if ms[i][0] == a[ms[i][1]]:
        ans[k] = ms[i][1]
        k += 1
    else:
        ans[t] = ms[i][1]
        t -= 1
print("出场顺序：", end=" ")
for i in ans:#输出出场顺序
    print(i + 1, end=" ")
print()
ta, tb = 0, 0#分别表示社团的准备结束时刻和表演结束时刻
for i in range(n):
    print(f'社团{ans[i]+1}准备时间表：{ta}', end = "--")
    ta += a[ans[i]]#计算社团i的准备结束时刻
    #如果社团(i-1)的tb早于社团i的ta，则延长tb，使得tb=ta
    if ta > tb: 
        tb = ta
    print(f'{ta}，表演时间表：{tb}', end = "--")
    tb += b[ans[i]]#计算社团i的表演结束时刻
    print(tb)
print(f'活动总时长：{tb}')
